/*
对象的初始化和清理
	生活中我们买的电子产品基本都会有恢复出厂设置，
	在某一天我们不用的时候也会删除一些自己信息数据保证安全

	c++中的面向对象来源于生活，每个对象也会有初始设置
	以及对象销毁前的清理数据的设置

*/

/*
构造函数和析构函数
（构造函数就是初始化，析构函数就是做清理）

	对象的初始化和清理也是两个非常重要的安全问题
		一个对象或者变量没有初始状态，对其使用后果是未知
		同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题
*/

/*
在c++中利用了构造函数和析构函数解决上述问题，这两个函数会被编译器自动调用，
完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此
我们如果不提供构造和析构，编译器会提供。

编译器提供的构造函数和析构函数是空实现。

（无论是自己写的，还是编译器提供的，编译器都会自动调用）
*/

/*
构造函数：
	主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，
	无需手动调用

析构函数：
	主要作用是 对象销毁前 系统自动调用，执行一些清理操作
*/

/*
构造函数语法： 类名(){}
	1、构造函数， 没有返回值也不写void
	2、函数名称于类名相同
	3、构造函数可以有参数，因此可以发生重载
	4、程序在调用对象时候会自动调用构造，无须手动调用，而且只会调用一次
*/

/*
析构函数语法： ~类名(){}
	1、析构函数，没有返回值也不写void
	2、函数名称与类名相同，在名称前面加上符号~
	3、析构函数不可以有参数，因此不可以发生重载
	4、程序在对象销毁前会自动调用析构，无须手动调用，而且只会调用一次
*/


#include <iostream>
using namespace std;

// 对象的初始化和清理
// 1、构造函数 进行初始化操作
class Person
{
public: // 作用域
	// 1.1、 构造函数
	// 没有返回值   不用写void
	// 函数名 与 类名相同
	// 构造函数可以有参数，可以发生重载
	// 创建对象的时候，构造函数会自动调用，而且只调用一次
	Person() // 无参的构造函数
	{
		cout << "Person构造函数的调用" << endl;
	}



	// 2、析构函数 进行清理操作
		//没有返回值  不写void
		//函数名和类名相同    在名称前加~
		//析构函数不可以有参数，不可以发生重载
		//对象在销毁前会自动调用析构函数，而且只会调用一次
	~Person() 
	{
		cout << "Person析构函数的调用" << endl;
	}
};

// 构造和析构都是必须有的实现，如果我们自己不提供，编译器会提供一个空实现构造和析构
void test01() 
{
	Person p; // 在栈上的数据，test01执行完毕后，就会释放这个对象
}

int main106() {

	test01(); // 调用了构造和析构， 因为test01函数调用完，这个函数就被释放了

	cout << "下一步\n" << endl;

	Person p; // 只调用了构造， 在main函数的return 0执行的时候，才会执行析构函数
	// 即对象被销毁的时候，才会调用

	system("pause");
	return 0;
}






